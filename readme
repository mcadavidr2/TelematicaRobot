1. Introducción

Este proyecto implementa un sistema cliente/servidor que permite controlar un robot simulado en un plano cartesiano 11×11 mediante comunicación TCP.

El servidor está desarrollado en C (Winsock2) y los clientes en Python, utilizando sockets, hilos y una interfaz gráfica en Tkinter.

El sistema soporta autenticación, movimientos del robot, difusión de estado a todos los clientes y generación de datos simulados de sensores.

2. Arquitectura del sistema

Servidor – C (Winsock2)
-Maneja múltiples clientes mediante hilos.
-Controla el estado global del robot.
-Procesa comandos:
-AUTH, SET, MOVE, LIST
-Valida límites del plano cartesiano.
-Envía actualizaciones de movimiento a todos los clientes.
-Genera datos aleatorios de sensores cada cierto tiempo.

Cliente Admin – Python (consola)

-Se conecta por TCP.
-Se autentica con AUTH admin 1234.
-Permite enviar comandos:
-SET x y
-MOVE UP/DOWN/LEFT/RIGHT
-LIST
-Recibe actualizaciones y datos de sensores.

Cliente GUI – Python (Tkinter)

-Muestra el robot en un plano 11×11.
-Escucha mensajes del servidor y actualiza la posición en tiempo real.
-Imprime los datos de sensores en consola.

3. Comandos implementados
Comando	Descripción
AUTH user    pass	Autentica usuario (solo admin tiene control).
SET x y	     Movimiento absoluto dentro del plano.
MOVE UP	     Mueve el robot una celda hacia arriba.
MOVE DOWN	   Mueve el robot una celda hacia abajo.
MOVE LEFT	   Mueve el robot una celda a la izquierda.
MOVE RIGHT	 Mueve el robot una celda a la derecha.
LIST	       Lista usuarios conectados.
SENSORS	    (Automático) Datos de temperatura, humedad y presión.

4. Validaciones implementadas

Autenticación obligatoria para comandos de movimiento.
-Límite de coordenadas: 0 ≤ x,y < 11.
-Movimientos fuera del rango devuelven:

BLOCKED

-Comandos inválidos:

UNKNOWN COMMAND

5. Datos simulados de sensores

El servidor genera automáticamente cada 15 segundos:

-Temperatura: 15–35 °C
-Humedad: 20–90 %
-Presión: 950–1050 hPa
-Formato del mensaje enviado:

SENSORS TEMP=23 HUM=45 PRESS=1013

6. Flujo de uso del sistema

1).Se inicia el servidor en C.

2).Se abren uno o varios clientes (admin o GUI).

3).El admin se autentica con AUTH admin 1234.

4).El admin envía comandos de movimiento.

5).El servidor valida y actualiza el estado del robot.

6).El servidor envía la posición a todos los clientes.

7).El cliente GUI actualiza la posición en pantalla.

8).El servidor envía periódicamente valores de sensores.

7. Ejemplos de Procedimientos
7.1 Autenticación

-Admin:

AUTH admin 1234


-Respuesta:

AUTH OK

7.2 Movimiento absoluto (SET)

-Comando:

SET 3 7


-Respuesta:

MOVED X=3 Y=7


GUI: Robot se mueve a (3,7).

7.3 Movimiento relativo (MOVE)

-Comando:

MOVE UP


-Respuesta:

MOVED X=3 Y=6


-Si intenta salirse del plano:

MOVE UP
BLOCKED

7.4 Listar clientes conectados
LIST


-Respuesta típica:

USERS:
anonimo
admin

7.5 Datos de sensores

-Datos enviados automáticamente:

SENSORS TEMP=30 HUM=52 PRESS=1007


El cliente GUI los muestra en consola.

8. Resultados obtenidos

-Robot totalmente funcional en cuadrícula 11×11.
-Comunicación estable entre múltiples clientes y el servidor.
-GUI actualizada en tiempo real.
-Sensores simulados funcionando correctamente.
-Movimientos verificados y limitados correctamente.
-Autenticación funcional con control de permisos.

9. Conclusión

El sistema cumple todos los requisitos propuestos:

-Comunicación TCP cliente-servidor.
-Multiproceso con hilos.
-Control remoto del robot.
-Movimientos absolutos y relativos.
-Validación de límites.
-Interfaz gráfica funcional.
-Difusión de mensajes.
-Simulación de sensores.
-Documentación con ejemplos de procedimientos.

El proyecto queda completo y funcionando correctamente, con una arquitectura modular, estable y extensible.